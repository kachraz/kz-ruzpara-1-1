use std::fs;
use std::io::{self, Write};
use std::path::Path;
use reqwest::Client;
use serde_json::{json, Value};

pub struct GeminiAnalyzer {
    api_key: String,
    model: String,
    client: Client,
}

impl GeminiAnalyzer {
    pub fn new(api_key: String, model: String) -> Self {
        Self {
            api_key,
            model,
            client: Client::new(),
        }
    }

    pub async fn analyze_contracts(&self, flattened_code: &str, project_name: &str) -> Result<String, Box<dyn std::error::Error>> {
        let prompt = self.create_analysis_prompt(flattened_code);
        
        let response = self.call_gemini_api(&prompt).await?;
        let analysis = self.parse_gemini_response(response)?;
        
        let report = self.format_analysis_report(analysis, project_name);
        Ok(report)
    }

    fn create_analysis_prompt(&self, code: &str) -> String {
        format!(
            r#"You are an expert Solidity security auditor. Please analyze the following smart contract code for potential vulnerabilities, security issues, and best practice violations.

Please provide a comprehensive analysis including:
1. **Critical Security Issues** - High-severity vulnerabilities that could lead to fund loss
2. **Medium Risk Issues** - Potential security concerns that should be addressed
3. **Low Risk Issues** - Code quality and best practice improvements
4. **Gas Optimization Opportunities** - Ways to reduce gas consumption
5. **Code Quality Assessment** - Overall code structure and maintainability
6. **Recommendations** - Specific actionable steps to improve the code

For each issue found, please provide:
- **Severity Level** (Critical/High/Medium/Low)
- **Description** of the issue
- **Location** in the code (function/line reference if possible)
- **Impact** of the vulnerability
- **Recommendation** for fixing the issue

Smart Contract Code to Analyze:

```solidity
{}
```

Please provide a detailed, structured analysis in markdown format."#,
            code
        )
    }

    async fn call_gemini_api(&self, prompt: &str) -> Result<Value, Box<dyn std::error::Error>> {
        let url = format!(
            "https://generativelanguage.googleapis.com/v1beta/models/{}:generateContent?key={}",
            self.model, self.api_key
        );

        let payload = json!({
            "contents": [{
                "parts": [{
                    "text": prompt
                }]
            }],
            "generationConfig": {
                "temperature": 0.1,
                "topK": 40,
                "topP": 0.95,
                "maxOutputTokens": 8192
            }
        });

        let response = self.client
            .post(&url)
            .header("Content-Type", "application/json")
            .json(&payload)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            return Err(format!("Gemini API error: {}", error_text).into());
        }

        let response_json: Value = response.json().await?;
        Ok(response_json)
    }

    fn parse_gemini_response(&self, response: Value) -> Result<String, Box<dyn std::error::Error>> {
        let candidates = response["candidates"]
            .as_array()
            .ok_or("No candidates in response")?;
        
        if candidates.is_empty() {
            return Err("Empty candidates array".into());
        }

        let content = candidates[0]["content"]["parts"][0]["text"]
            .as_str()
            .ok_or("No text content in response")?;

        Ok(content.to_string())
    }

    fn format_analysis_report(&self, analysis: String, project_name: &str) -> String {
        let timestamp = chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC");
        
        format!(
            r#"# Gemini AI Security Analysis Report

## Project: {}
**Analysis Date:** {}  
**AI Model:** {}  
**Analyzer:** Aderyn + Gemini AI

---

{}

---

## Disclaimer
This analysis was generated using AI and should be used as a starting point for manual security review. Always conduct thorough manual audits and testing before deploying smart contracts to production.

## About This Report
- **Generated by:** Aderyn with Gemini AI integration
- **Analysis Type:** Automated AI-powered security review
- **Scope:** All flattened contract code provided
- **Limitations:** AI analysis may miss complex business logic vulnerabilities or novel attack vectors

For comprehensive security assurance, consider:
1. Manual code review by experienced auditors
2. Formal verification for critical components
3. Extensive testing including edge cases
4. Bug bounty programs
5. Gradual deployment with monitoring
"#,
            project_name, timestamp, self.model, analysis
        )
    }
}

pub fn flatten_contracts(root_path: &str) -> Result<(String, String), Box<dyn std::error::Error>> {
    let mut flattened_code = String::new();
    let mut project_name = "Unknown Project".to_string();
    
    // Try to get project name from various sources
    if let Ok(package_json) = fs::read_to_string(format!("{}/package.json", root_path)) {
        if let Ok(json) = serde_json::from_str::<Value>(&package_json) {
            if let Some(name) = json["name"].as_str() {
                project_name = name.to_string();
            }
        }
    } else if let Ok(foundry_toml) = fs::read_to_string(format!("{}/foundry.toml", root_path)) {
        // Extract project name from foundry.toml if available
        for line in foundry_toml.lines() {
            if line.trim().starts_with("name") {
                if let Some(name) = line.split('=').nth(1) {
                    project_name = name.trim().trim_matches('"').to_string();
                    break;
                }
            }
        }
    } else {
        // Use directory name as fallback
        if let Some(dir_name) = Path::new(root_path).file_name() {
            project_name = dir_name.to_string_lossy().to_string();
        }
    }

    // Find and read all Solidity files
    collect_solidity_files(root_path, &mut flattened_code)?;
    
    if flattened_code.is_empty() {
        return Err("No Solidity files found in the project".into());
    }

    Ok((flattened_code, project_name))
}

fn collect_solidity_files(dir: &str, flattened_code: &mut String) -> Result<(), Box<dyn std::error::Error>> {
    let entries = fs::read_dir(dir)?;
    
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_dir() {
            // Skip common directories that don't contain source code
            if let Some(dir_name) = path.file_name() {
                let dir_str = dir_name.to_string_lossy();
                if dir_str == "node_modules" || dir_str == ".git" || dir_str == "artifacts" || dir_str == "cache" {
                    continue;
                }
            }
            collect_solidity_files(&path.to_string_lossy(), flattened_code)?;
        } else if let Some(extension) = path.extension() {
            if extension == "sol" {
                let content = fs::read_to_string(&path)?;
                flattened_code.push_str(&format!("\n// File: {}\n", path.display()));
                flattened_code.push_str(&content);
                flattened_code.push_str("\n\n");
            }
        }
    }
    
    Ok(())
}

pub fn prompt_for_api_credentials() -> Result<(String, String), Box<dyn std::error::Error>> {
    println!("Gemini AI Analysis Setup");
    println!("========================");
    
    // Prompt for API key
    print!("Enter your Gemini API key: ");
    io::stdout().flush()?;
    let api_key = rpassword::read_password()?;
    
    if api_key.trim().is_empty() {
        return Err("API key cannot be empty".into());
    }
    
    // Prompt for model selection
    println!("\nAvailable Gemini models:");
    println!("1. gemini-1.5-flash (Fast, cost-effective)");
    println!("2. gemini-1.5-pro (More capable, higher cost)");
    println!("3. gemini-1.0-pro (Legacy model)");
    
    print!("Select model (1-3) [default: 1]: ");
    io::stdout().flush()?;
    
    let mut input = String::new();
    io::stdin().read_line(&mut input)?;
    
    let model = match input.trim() {
        "2" => "gemini-1.5-pro",
        "3" => "gemini-1.0-pro", 
        _ => "gemini-1.5-flash", // default
    };
    
    println!("Selected model: {}", model);
    
    Ok((api_key.trim().to_string(), model.to_string()))
}